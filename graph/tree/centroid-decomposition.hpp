#pragma once

#include "../graph-template.hpp"

/**
 * @brief Centroid-Decomosition(重心分解)
 */
template <typename T>
struct CentroidDecomposition : Graph<T> {
 public:
  using Graph<T>::Graph;
  using Graph<T>::g;
  Graph<int> tree;

  int build(int t = 0) {
    sub.assign(g.size(), 0);
    v.assign(g.size(), 0);
    tree = Graph<int>(g.size());
    return build_dfs(0);
  }

  explicit CentroidDecomposition(const Graph<T> &g) : Graph<T>(g) {}

 private:
  vector<int> sub;
  vector<int> v;

  inline int build_dfs(int idx, int par) {
    sub[idx] = 1;
    for (auto &to : g[idx]) {
      if (to == par || v[to]) continue;
      sub[idx] += build_dfs(to, idx);
    }
    return sub[idx];
  }

  inline int search_centroid(int idx, int par, const int mid) {
    for (auto &to : g[idx]) {
      if (to == par || v[to]) continue;
      if (sub[to] > mid) return search_centroid(to, idx, mid);
    }
    return idx;
  }

  inline int build_dfs(int idx) {
    int centroid = search_centroid(idx, -1, build_dfs(idx, -1) / 2);
    v[centroid] = true;
    for (auto &to : g[centroid]) {
      if (!v[to]) tree.add_directed_edge(centroid, build_dfs(to));
    }
    v[centroid] = false;
    return centroid;
  }
};
