---
documentation_of: //structure/segment-tree/persistent-segment-tree.hpp
---

## 概要

セグメント木のある要素に対して何らかの更新を行うとする. ここで更新後のセグメント木をすべてコピーして残しておくことが永続であるが, これを単純に実装すると, $1$ 回のコピーに $O(N)$ かかってこわれてしまう. $1$ 回の更新によって $O(\log N)$ 個のノードの情報しか変化しないので, 変化したノードの情報だけ新しくノードを生成してその部分のみ張り替えるする操作を行えば $O(\log N)$ でのコピーが可能になり, これは一般のセグメント木の計算量と変わらない.

* `PersistentSegmentTree(f, M1)`: `f` は2つの区間の要素をマージする二項演算, `M1` はモノイドの単位元である.
* `build(v)`: 配列 `v` を各要素としたセグメント木を構築し, その根を返す.
* `update(t, k, x)`: `t` を根とするセグメント木に対し `k` 番目の要素を `x` に更新し, 更新後の根を返す.
* `query(t, a, b)`: `t` を根とするセグメント木に対し, 区間 $[a, b)$ の要素を二項演算した結果を返す.

## 計算量

* `build(v)`: $O(N)$
* クエリ: $O(\log N)$ 
